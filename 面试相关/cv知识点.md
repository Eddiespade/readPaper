图像滤波
图像滤波：在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制。

平滑：也称模糊, 是一项简单且使用频率很高的图像处理方法。平滑的一种作用就是用来减弱噪声。

1.列出常见的线性滤波器

低通滤波器 允许低频通过

高通滤波器 允许高频通过

带通滤波器 允许一定范围的频率通过

带阻滤波器 允许一定范围的频率通过并阻止其他的频率通过

全通滤波器 允许所有频率通过，只改变相位

陷波滤波器 阻止一个狭窄频率范围通过

2.线性滤波与非线性滤波

线性滤波：方框滤波 均值滤波 高斯滤波   非线性滤波：中值滤波 双边滤波

①方框滤波（boxblur函数）：每一个输出像素的是内核邻域像素值的平均值得到

②均值滤波（Blur函数）：均值滤波实际上就是用均值代替原图像中的各个像素值。

把每个像素都用周围的8个像素来做均值操作

原理：在图像上，对待处理的像素给定一个模板，该模板包括了其周围的邻近像素。将模板中的全体像素的均值来替代原来的像素值的方法。

方法：对待处理的当前像素，选择一个模板，该模板为其近邻的若干像素组成，

用模板中像素的均值来代替原像素值的方法。

优点：把每个像素都用周围的 8 个像素做均值操作，平滑图像速度快、算法简单。

缺点：1、在降低噪声的同时，使图像产生模糊，特别是边缘和细节处，而且模糊尺寸越大，图像模糊程度越大。2、对椒盐噪声的平滑处理效果不理想。（无法去掉噪声）

不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变模糊，不能很好去除噪声点。

③高斯滤波（Gauss filter）

高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。

高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。

高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值用。

高斯平滑滤波器对于抑制服从正态分布的噪声非常有效。

④中值滤波（Median filter）

中值滤波是一种典型的非线性滤波技术，基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像边缘细节。

⑤双边滤波

双边滤波（Bilateral filter）是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。

用在对边缘信息重要，需要保留的图像去噪。缺点是由于双边滤波保证了边缘信息，所以其保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净地滤去，只能对于低频信息进行较好地滤波。

⑥维纳滤波

维纳滤波是一种自适应最小均方差滤波器。维纳滤波的方法是一种统计方法，它用的最优准则是基于图像和噪声各自相关的相关矩阵，它能根据图像的局部方差调整滤波器的输出，局部方差越大，滤波器的平滑作用就越强。

椒盐噪声用什么滤波？ 中值滤波

边缘检测
边缘检测的目的就是找到图像中亮度变化剧烈的像素点构成的集合，表现出来往往是轮廓。如果图像中边缘能够精确的测量和定位，那么，就意味着实际的物体能够被定位和测量，包括物体的面积、物体的直径、物体的形状等就能被测量。

边缘检测算子有哪些：

一阶：Roberts Cross算子, Prewitt算子, Sobel算子, Canny算子，罗盘算子

二阶：Laplacian算子，Marr-Hildreth,在梯度方向的二阶导数过零点。

1.介绍canny边缘检测

Canny边缘检测是一种非常流行的边缘检测算法，是John Canny在1986年提出的。它是一个多阶段的算法，即由多个步骤构成。

1.图像降噪2.计算图像梯度3.非极大值抑制4.阈值筛选

首先，图像降噪。我们知道梯度算子可以用于增强图像，本质上是通过增强边缘轮廓来实现的，也就是说是可以检测到边缘的。但是，它们受噪声的影响都很大。那么，我们第一步就是想到要先去除噪声，因为噪声就是灰度变化很大的地方，所以容易被识别为伪边缘。

第二步，计算图像梯度，得到可能边缘。我们在前面的关于《图像梯度》文章中有所介绍，计算图像梯度能够得到图像的边缘，因为梯度是灰度变化明显的地方，而边缘也是灰度变化明显的地方。当然这一步只能得到可能的边缘。因为灰度变化的地方可能是边缘，也可能不是边缘。这一步就有了所有可能是边缘的集合。

第三步，非极大值抑制。通常灰度变化的地方都比较集中，将局部范围内的梯度方向上，灰度变化最大的保留下来，其它的不保留，这样可以剔除掉一大部分的点。将有多个像素宽的边缘变成一个单像素宽的边缘。即“胖边缘”变成“瘦边缘”。

第四步，双阈值筛选。通过非极大值抑制后，仍然有很多的可能边缘点，进一步的设置一个双阈值，即低阈值（low），高阈值（high）。灰度变化大于high的，设置为强边缘像素，低于low的，剔除。在low和high之间的设置为弱边缘。进一步判断，如果其领域内有强边缘像素，保留，如果没有，剔除。

这样做的目的是只保留强边缘轮廓的话，有些边缘可能不闭合，需要从满足low和high之间的点进行补充，使得边缘尽可能的闭合。

canny算子是怎么做的？简述Canny算子的计算步骤

①将彩色图像转化为灰度图；②使用高斯滤波器平滑图像；③计算图像梯度的幅值和方向；④对梯度幅值进行非极大值抑制；⑤使用双阈值进行边缘的检测和连接；Canny算子使用滞后阈值，滞后阈值需要两个阈值(高阈值和低阈值)。如果某一像素位置的幅值超过 高 阈值, 该像素被保留为边缘像素。如果某一像素位置的幅值小于 低 阈值, 该像素被排除。如果某一像素位置的幅值在两个阈值之间,该像素仅仅在连接到一个高于 高 阈值的像素时被保留。

2.简述一下sobel算子

Sobel算子是一个主要用作边缘检测的离散微分算子(discrete differentiation operator)。它Sobel算子结合了高斯平滑和微分求导，用来计算图像灰度函数的近似梯度。在图像的任何一点使用此算子，将会产生对应的梯度矢量或是其法矢量。

当内核大小为 3 时, 我们的Sobel内核可能产生比较明显的误差(毕竟，Sobel算子只是求取了导数的近似值而已)。为解决这一问题，OpenCV提供了Scharr 函数，但该函数仅作用于大小为3的内核。该函数的运算与Sobel函数一样快，但结果却更加精确。

3.简述传统算法中边缘检测的一般步骤

①滤波：滤波去除噪声；②增强：增强边缘的特征；③将边缘通过某种方式提取出来，完成边缘检测。

4.如何求边缘，45°边缘

Sobel算子实现水平边缘检测、垂直边缘检测；45度、135度角边缘检测。

5. SIFT

尺度不变特征变换(Scale-invariant feature transform, SIFT)是计算机视觉中一种检测、描述和匹配图像局部特征点的方法，通过在不同的尺度空间中检测极值点或特征点(Conrner Point, Interest Point)，提取出其位置、尺度和旋转不变量，并生成特征描述子，最后用于图像的特征点匹配。

SIFT特征是如何保持旋转不变性的？

sift特征通过将坐标轴旋转至关键点的主方向来保持旋转不变性，关键点的主方向是通过统计关键点局部邻域内像素梯度的方向分布直方图的最大值得到的

SIFT特征匹配

对两幅图像中检测到的特征点，可采用特征向量的欧式距离作为特征点相似性的度量，取图像1中某个关键点，并在图像2中找到与其距离最近的两个关键点，若最近距离与次近距离的比值小于某个阈值，则认为距离最近的这一对关键点为匹配点。降低比例阈值，SIFT匹配点数量会减少，但相对而言会更加稳定。阈值ratio的取值范围一般为0.4~0.6。

SIFT特征的特点

SIFT是一种检测、描述、匹配图像局部特征点的算法，通过在尺度空间中检测极值点，提取位置、尺度、旋转不变量，并抽象成特征向量加以描述，最后用于图像特征点的匹配。SIFT特征对灰度、对比度变换、旋转、尺度缩放等保持不变性，对视角变化、仿射变化、噪声也具有一定的鲁棒性。但其实时性不高，对边缘光滑的目标无法准确提取特征点。

6.SURF特征匹配

加速鲁棒特征(Speed Up Robust Feature, SURF)和SIFT特征类似，同样是一个用于检测、描述、匹配图像局部特征点的特征描述子。SIFT是被广泛应用的特征点提取算法，但其实时性较差，如果不借助于硬件的加速和专用图形处理器(GPUs)的配合，很难达到实时的要求。对于一些实时应用场景，如基于特征点匹配的实时目标跟踪系统，每秒要处理数十帧的图像，需要在毫秒级完成特征点的搜索定位、特征向量的生成、特征向量的匹配以及目标锁定等工作，SIFT特征很难满足这种需求。SURF借鉴了SIFT中近似简化(DoG近似替代LoG)的思想，将Hessian矩阵的高斯二阶微分模板进行了简化，借助于积分图，使得模板对图像的滤波只需要进行几次简单的加减法运算，并且这种运算与滤波模板的尺寸无关。SURF相当于SIFT的加速改进版本，在特征点检测取得相似性能的条件下，提高了运算速度。整体来说，SUFR比SIFT在运算速度上要快数倍，综合性能更优。

7.LBP特征

局部二值模式(Local Binary Patter, LBP)是一种用来描述图像局部纹理特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点，它将图像中的各个像素与其邻域像素值进行比较，将结果保存为二进制数，并将得到的二进制比特串作为中心像素的编码值，也就是LBP特征值。LBP提供了一种衡量像素间邻域关系的特征模式，因此可以有效地提取图像的局部特征，而且由于其计算简单，可用于基于纹理分类的实时应用场景，例如目标检测、人脸识别等。

8.图像特征提取之HOG特征

方向梯度直方图(Histogram of Oriented Gradient, HOG)特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。Hog特征结合SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。

9.简要阐述一下SIFT和SURF算法的异同点

![img](https://s4.51cto.com/images/blog/202106/22/e6a42f9a62dcde203b9e6063a1e3a03a.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)


①尺度空间：SIFT使用DoG金字塔与图像进行卷积操作，而且对图像有做降采样处理；SURF是用近似DoH金字塔(即不同尺度的box filters)与图像做卷积，借助积分图，实际操作只涉及到数次简单的加减运算，而且不改变图像大小。

②特征点检测：SIFT是先进行非极大值抑制，去除对比度低的点，再通过Hessian矩阵剔除边缘点。而SURF是计算Hessian矩阵的行列式值(DoH)，再进行非极大值抑制。

③特征点主方向：SIFT在方形邻域窗口内统计梯度方向直方图，并对梯度幅值加权，取最大峰对应的方向；SURF是在圆形区域内，计算各个扇形范围内x、y方向的Haar小波响应值，确定响应累加和值最大的扇形方向。

④特征描述子：SIFT将关键点附近的邻域划分为4×4的区域，统计每个子区域的梯度方向直方图，连接成一个4×4×8=128维的特征向量；SURF将20s×20s的邻域划分为4×4个子块，计算每个子块的Haar小波响应，并统计4个特征量，得到4×4×4=64维的特征向量。

总体来说，SURF和SIFT算法在特征点的检测取得了相似的性能，SURF借助积分图，将模板卷积操作近似转换为加减运算，在计算速度方面要优于SIFT特征。

10.比较一下SIFT，HOG和LBP这三个特征提取算法

![img](https://s8.51cto.com/images/blog/202106/22/0d1dca0985942765d9bae181b6f666fa.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)


11.说出几种传统算法中常用的特征检测算法

①FAST：Fast Feature Detector

②STAR：Star Feature Detector

③SIFT:Scale Invariant Feature Transform

④SURF:Speeded UP Robust Feature 加速版的具有鲁棒性的特征检测算法

⑤ORB:是Oriented Brief的简称，是brief算法的改进版，综合性能相对较好的算法。

12.简述霍夫变换的原理

使用极坐标表示一条直线，可以由参数极径和极角（r,θ） 表示。霍夫变换就采用这种表示直线的方式。即r=xcosθ+ysinθ  意味着每一对（r,θ）代表一条通过点（x，y）的直线，如果对于一个给定点（x,y）,我们在极坐标对极径极角平面绘出通过它的直线，可以到一条正弦曲线（r>0 and 0<θ<2π）。对图像上所有点进行上述操作，如果两个不同点进行上述操作后发现曲线相交，则意味着他们通过同一条直线。

以上说明，一般来说，一条直线能够通过在平面θ-r上寻找交于一点的曲线数量来检测。越多曲线交于一点则意味着这个交点表示的直线由更多点组成。可以通过设置直线上点的阈值来定义多少条曲线交于一点才能被认为是检测到一条直线。

霍夫变换考察图像中每个点对应曲线间的交点，如果交于一点的曲线的数量超过了阈值，则可以认为这个交点所代表的参数对（r，θ）在原图像中为一条直线。

13.简述霍夫圆变换原理

从平面坐标圆上的点到极坐标转换的三个参数C(x0,y0,r)其中x0,y0是圆心，r 取一固定值时theta扫描360度，x y 跟着变化， 若多个边缘点对应的三维空间曲线交于一点，则他们在共同圆上，在圆心处有累积最大值，也可以用同样的阈值的方法来判断一个圆是否被检测到。

14.简述opencv中主要有哪些模块？

Core —— 核心组件模块
作为核心组件，Core 做的事情肯定特别多，也比较基础。包括基本数据结构、动态数据结构、绘图函数、数组操作相关函数、辅助功能与系统函数和宏、XML/YML、聚类、与OpenGL 的交互操作。

Imgproc 图像处理模块
包括图像滤波、几何图像变换、混合图像变换、直方图、结构分析及形状描述、运动分析及目标跟踪、特征及目标检测。

Highgui——顶层GUI及视频I/O
包括用户界面、读/写图像及视频、QT新功能。

Video——视频分析
包括运动分析及目标跟踪。

Calib3d——摄像机标定及3维重建
包括摄像机标定及3维重建。

Features2d——2维特征框架
包括特征检测与描述、特征检测提取匹配接口、关键点与匹配点绘图及对象分类。

Objdetect——目标检测
包括级联分类器及SVM.

MI——机器学习
包括统计模型、贝叶斯分类器、最近邻分类器、支持向量机、决策树、提升、梯度提升树、随机树、超随机树、最大期望、神经网络及机器学习数据。

FLann——聚类及多维空间搜索
快速最近邻搜索及聚类。

Gpu——计算机视觉中GPU加速
GPU模块及数据结构，包含图像处理与分析模块。

Photo——计算图像
图像修复及去噪。

Stitching——图像拼接
图像拼接顶层操作函数、旋转、自动标定、仿射变换、接缝估计、曝光补充及图像融合技术。

15. opencv中CV_8UC3代表什么意思？

8表示8位，UC--代表--unsigned int--无符号整形，3 -代表一张图片的通道数3

16.简述opencv中的Scalar类

Scalar（）表示具有4个元素的数组，在opencv中被大量用于传递像素值，比如RGB颜色值。如果用不到第四个参数，则不需要写出来，若只写三个参数，则opencv会认为只需要传递三个参数。

17.简述.hpp和.h的区别

.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数，也不用再发布lib与dll文件，因此非常适合用来编写公用的开源库。

18.简述一下什么是光流？

光流(Optical flow or optic flow)是关于视域中的物体运动检测中的概念。用来描述相对于观察者的运动所造成的观测目标、表面或边缘的运动。

19.简述常见的颜色系统

①RGB是最常见的颜色系统,采用人眼相似的工作机制，也被显示设备所采用。②HSV和HLS把颜色分解成色调，饱和度和亮度/明度，描述颜色更加自然，可以通过抛弃最后一个元素使算法对输入图像的光照条件不敏感。③YCrCb颜色系统在JPEG图像格式中广泛使用。④CIELab是一种在感知上均匀的颜色空间，适合用来度量两个颜色之间的距离。

20.简述访问图像中像素的3种方法

①指针访问，C操作符[]；②迭代器iterator；③动态地址计算。

21.简述一下图像处理中的膨胀和腐蚀操作

膨胀和腐蚀都是对白色（高亮）部分进行操作的。膨胀是图像中的高亮部分进行膨胀，效果图拥有比原图更大的高亮区域，腐蚀是原图中的高亮部分被腐蚀，效果图拥有比原图更小的高亮区域。从数学原理上说，膨胀就是求局部最大值，并把这个最大值赋值给参考点指定像素，这样会使图像中高亮区域逐渐增长，腐蚀与之相反。

22.简述开运算的操作流程和使用场景

开运算就是先腐蚀后膨胀的过程。可以用来消除小物体，在纤细点处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积。

23.简述闭运算的操作流程和使用场景

闭运算就是先膨胀后腐蚀的过程，闭运算能够排除小型黑洞(黑色区域)。

24.简述形态学梯度的定义和使用场景

形态学梯度是膨胀图与腐蚀图之差，对二值图进行这一操作可以将团块（blob）的边缘突出出来，可以用形态学梯度来保留物体的边缘轮廓。

25.简述顶帽（礼帽）运算的定义和使用场景

顶帽是原图像与开运算的结果图之差。因为开运算的结果是放大了裂缝或者局部低亮度的区域，所以从原图中减去开运算之后的图，得到的效果图突出了比原图轮廓周围区域更加明亮的区域。顶帽运算常用来分离比临近点亮一些的斑块。在一幅图像具有大幅的背景，而微小物品比较有规律的情况下，可以使用顶帽运算进行背景提取。

26.简述黑帽运算的定义和使用场景

黑帽（Black Hat）运算为闭运算结果图与原图像之差。黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，且这一操作和选择的核的大小相关。所以，黑帽运算用来分离比邻近点暗一些的斑块。效果图有着非常完美的轮廓。

27.简述一下漫水填充法

漫水填充法是一种用特定的颜色填充算法填充连通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常用来标记或者分离图像的一部分进行处理或分析。简单说，就是自动选中和种子点相连的区域，接着将该区域替换成指定的颜色。

28.简述一下仿射变换的定义

仿射变换，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间的过程。它保持了二维图形的平直性（直线变换之后依然是直线）和平行性。一个任意的仿射变换都能表示为乘以一个矩阵（线性变换）接着再加上一个向量（平移）的形式。

29.简述一些图像金字塔的种类和区别

一般情况下有两种类型的图像金字塔，分别是：高斯金字塔(Gaussianpyramid): 用来向下采样，主要的图像金字塔；拉普拉斯金字塔(Laplacianpyramid): 用来从金字塔低层图像重建上层未采样图像，在数字图像处理中也即是预测残差，可以对图像进行最大程度的还原，配合高斯金字塔一起使用。两者的简要区别：高斯金字塔用来向下降采样图像，拉普拉斯金字塔用来从金字塔低层图形中向上采样，重建一个图像可以将拉普拉斯金字塔理解为高斯金字塔的逆形式。

30.简述凸包的定义

给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点。理解物体形状或轮廓的一种比较有用的方法便是计算一个物体的凸包。

31.简述反向投影的定义和使用场景

反向投影是一种记录给定图像中的像素点如何适应直方图模型像素分布的方式。简单的讲，就是首先计算某一特征的直方图模型，然后使用模型去寻找图像中存在的该特征。反向投影用于在输入图像（通常较大）中查找与特定图像（通常较小）最匹配的点或者区域，也就是定位模板图像出现在输入图像的位置。

32.简述harris角点检测算法原理和使用场景

harris角点检测时一种直接基于灰度图像的角点提取算法，稳定性高，尤其对于L型角点检测精度高。但是由于采用了高斯滤波，运算速度相对比较的慢，角点信息有丢失和位置偏移的现象，而且角点提取有聚簇现象。

33.简述一下分水岭算法

分水岭算法是一种图像区域分割法，在分割的过程中，它会把跟临近像素间的相似性作为重要的参考依据，从而将在空间位置上相近并且灰度值相近的像素点互相连接起来构成一个封闭的轮廓，封闭性是分水岭算法的一个重要特征。分水岭算法常用的操作步骤：分水岭算法常用的操作步骤：彩色图像灰度化，然后再求梯度图，最后在梯度图的基础上进行分水岭算法，求得分段图像的边缘线。


-----------------------------------
## 高斯滤波

> 先引入两个问题。
>  1.图像为什么要滤波？
>  答：a.消除图像在数字化过程中产生或者混入的噪声。
>  b.提取图片对象的特征作为图像识别的特征模式。
>  2.滤波器该如何去理解?
>  答：滤波器可以想象成一个包含加权系数的窗口或者说一个镜片，当使用滤波器去平滑处理图像的时候，就是把通过这个窗口或者镜片去看这个图像。

滤波器分为很多种，有方框滤波、均值滤波、高斯滤波等。
 **高斯滤波是一种线性平滑滤波，适用于消除高斯噪声。**
 所以在讲高斯滤波之前，先解释一下什么是高斯噪声？

#### 高斯噪声

首先，**噪声**在图像当中常表现为一引起较强视觉效果的孤立像素点或像素块。简单来说，噪声的出现会给图像带来干扰，让图像变得不清楚。
 **高斯噪声**就是它的概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度又是均匀分布的，则称它为高斯白噪声。高斯白噪声的二阶矩不相关，一阶矩为常数，是指先后信号在时间上的相关性。

**高斯滤波器是根据高斯函数的形状来选择权值的线性平滑滤波器**
 所以接下来再讲解一下高斯函数和高斯核。

#### 高斯函数

![img](https:////upload-images.jianshu.io/upload_images/14512145-cb79bc3d41cc37fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/708/format/webp)



注：σ的大小决定了高斯函数的宽度。

#### 高斯核

理论上，高斯分布在所有定义域上都有非负值，这就需要一个无限大的卷积核。实际上，仅需要取均值周围3倍标准差内的值，以外部份直接去掉即可。
 **高斯滤波的重要两步就是先找到高斯模板然后再进行卷积**，模板（mask在查阅中有的地方也称作掩膜或者是高斯核）。所以这个时候需要知道它怎么来？又怎么用？
 举个栗子：
 假定中心点的坐标是（0,0），那么取距离它最近的8个点坐标，为了计算，需要设定σ的值。假定σ=1.5，则模糊半径为1的高斯模板就算如下

![img](https:////upload-images.jianshu.io/upload_images/14512145-04d41990169b094a.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)


 这个时候我们我们还要确保这九个点加起来为1（这个是高斯模板的特性），这9个点的权重总和等于0.4787147，因此上面9个值还要分别除以0.4787147，得到最终的高斯模板。

![img](https:////upload-images.jianshu.io/upload_images/14512145-049ada57d888bf79.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)



#### 高斯滤波计算

有了高斯模板，那么高斯滤波的计算便顺风顺水了。
 举个栗子：
 假设现有9个像素点，灰度值（0-255）的高斯滤波计算如下：

![img](https:////upload-images.jianshu.io/upload_images/14512145-530497b10b412a95.png?imageMogr2/auto-orient/strip|imageView2/2/w/1075/format/webp)

将这9个值加起来，就是中心点的高斯滤波的值。
 对所有点重复这个过程，就得到了高斯模糊后的图像。

